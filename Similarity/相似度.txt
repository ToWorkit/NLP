相似度
	1. 语义角度
		歌神，张学友
		龙门客栈，东方不败
	2. 字面角度
		我吃饱饭了，我吃不饱饭
	3. 垂类(专业版) -> 垂直分类
		旅游，视频，音乐，游戏 -> 垂直领域(细分行业(一个领域内的所有信息，可以和百度(多领域)相对比))
			旅游搜索 -> 机票，酒店，吃喝玩乐
			百度搜索 -> 平台，百科，新闻 ...
自动摘要
	1. 挖掘关键词
	2. 找出包含关键词的关键句子
	3. 把句子整合成一个片段(摘要)
	
	余弦相似度
		余弦值接近1，夹角趋于0，表明两个向量越相似
		余弦相似度需要考虑 A 和 B 的延伸长度，夹角大小(延伸越长夹角越大？) 
			cos() = a * b / ||a|| * ||b|| 具体百度
				分子: 维度相乘求和 (向量内积)
				分母: 所有维度的平方和再开方
			es:
				a (1, 4)
				b (2, 1)
							1 * 2 + 4 * 1
						____________________
					
				sqrt(1 * 1 + 4 * 4) * sqrt(2 * 2 + 1 * 1)

			我吃饱饭了吃饱了
			我吃不饱饭好饿啊
				中文分词
				所有词库
					我 吃 不 饱 饭 了 好 饿 啊
				计算词频 (注意：所有词库和计算词频时的句子 词的排序要一致(以所有词库为基准计算词频)，因为要保证维度相同)
					我/吃/饱/饭/了/吃/饱/了 (1, 2, 0, 2, 1, 2, 0, 0, 0) a
					我/吃/不/饱/饭/好/饿/啊 (1, 1, 1, 1, 1, 0, 1, 1, 1) b
				代入公式
					余弦相似度 cos() = a * b / ||a|| * ||b|| 
				
	(一)TF-IDF
		TF: 词频，除去停用词(常用词，助词，名词，动词，但并不代表所有停用词权重都低)后一个词在文章中出现的次数 (Term Frequency)
			逆向假设
				某一个词比较少见，但是在当前文章中多次出现，那么该词有极大的可能性为当前文章的关键词(大的权重)，表示出了当前文章的特性
					常见词添加最小权重 (嗯，好，的，走)
					较常见词添加较小权重 (国内，国外，屋内，屋外)
					不常见词添加大权重 (雪崩，中毒，涨停，沉船)
			(1) 某个词在文章中出现的次数
				————————————————————————	=> 适用于消除文章篇幅和词频的差异，但值会忽高忽低
					文章的总词数
				词A
					x 文章共 100 字，出现 10 次		1/10
					y 文章共 10000 字，出现 100 次	1/100
					
			(2) 	某个词在文章中出现的次数(词频)
					—————————————————————————————— 		=> 压缩范围，值更加平缓
				 该文章中词频最高的词的出现次数(词频)
			
		IDF: 逆文档频率，一个词在所有文章中出现的次数(词频)
			如果一个词在很多文章中都有出现则IDF值偏低，相反一个词在所有文章中出现的频率都很低则IDF值高
				极端情况下一个词在所有的文章中都有出现则IDF值为0
			
							总共有多少篇文章
			log (			————————————————				) 
					包含某个词的文章个数 + 1 (避免出现 0)
					
			x越大y越大，(百度log函数)，但是当值达到临界时会趋于平稳增长，取log就是为了将值域压缩到一定的范围之内
		
		TF-IDF
			TF * IDF
			TF-IDF与一个词在文档中的出现次数成正比，与包含该词的文档数成反比
		
		• 使用TF-IDF算法，找出两篇文章的关键词
		• 每篇文章各取出若干个关键词（比如20个），合并成一个集合，计算每篇文章对于这个集合中的词的词频（为了避免文章长度的差异，可以使用相对词频(1)）
		• 生成两篇文章各自的词频向量
		• 计算两个向量的余弦相似度，值越大就表示越相似
		
		
	(二)LCS
		最长公共子序列(Longest Common Subsequence)
			一个序列 X 任意删除若干个字符得到新的序列 Y，则 Y 叫作 X 的子序列
			两个序列 A 和 B 的公共子序列中，长度最长的为 A 和 B 的最长公共子序列
				字符串 12454 与 2454123 的最长公共子序列为 2454 => 最长公共子串(Longest Common Substring), 要求子序列是连续的
				字符串 acdfg 与 adfc 的最长公共子序列为 adf => 可以不连续但是顺序必须保证
			
			(1) 生物学
				求出两个序列中最长的公共子序列算法，应用到对基因的序列比对，以推测序列的结构，功能和演化过程
			(2) 辨别抄袭
				两段文字之间的 相似度，对一段文字进行修改之后，计算改动前后文字的最长公共子序列，将除此子序列外的部分提取出来，该方法可判断其修改的部分
				
		计算A与B之间的LCS
			我吃饱饭了 5
			你吃饱饭吃好了吗 8
				最长公共子序列 => 吃饱饭了 4
			
			4 * 2 / (5 + 8) = 8 / 13
				
			
			(1)动态规划
				找到一种可迭代的规律不断的进行迭代
				
				字符串X，长度为m，从1开始数
				字符串Y，长度为n，从1开始数
					Xi = <x1, x2, ...., xi> (右下角)即X序列的前i个字符(1<=i<=m) Xi 计作 "字符串X的i前缀"
						今天周末不出去玩吗
						len = 9
						i = 3
						Xi = 今天周
					Yj = <y1, y2, ...., yj> (右下角)即Y序列的前j个字符(1<=j<=n) Yj 计作 "字符串Y的j前缀"
				LCS(X, Y)为字符串X和Y的最长公共子序列，即为Z = <z1, z2, ..., zK> => Z = LCS(X, Y)
				
				如果xm = yn（最后一个字符相同），则：Xm 与 Yn的最长公共子序列Zk的最后一个字符必定为 xm(或者yn)
					• zk = xm = yn
					• LCS(Xm, Yn) = LCS(Xm-1, Yn−1) + xm
				
				
				如果Xm = Yn
					  1 2 3 4 5 6 7
					X B D C A B A	
					Y A B C B D A B
				
				• 对于上面的字符串X和Y：
				• x3 = y3 = ‘C’ 则有：LCS(BDC, ABC) = LCS(BD, AB) + ‘C’	=> C
				• x5 = y4 = ‘B’ 则有：LCS(BDCAB, ABCB) = LCS(BDCA, ABC) + ‘B’ => B
				
				如果xm ≠ yn，则LCS(Xm, Yn) = LCS(Xm - 1, Yn)，或者LCS(Xm, Yn) = LCS(Xm, Yn−1), 即LCS(Xm, Yn) = max{LCS(Xm-1, Yn), LCS(Xm, Yn−1)}, 最长即最大 => max
				
			
		
		
		
		
		
		
		
		
		
		
		
		
		
					